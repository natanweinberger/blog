import { Post } from '@/components/post'
import Container from '@/components/container';

<Container>
    <Post>

# Maintainable Code as a Competitive Advantage

This isn't a post extolling maintainability as just a virtue.
If you're reading this, I'm guessing you agree that good code is better than bad code, and that maintainability is a big contributor to good code.
However, the difference it actually makes isn't always obvious, especially during early iterations.

Writing good, maintainable code takes time and effort. When does it pay off?

## What is "good", anyway?

When I think of good code, I think of some combination of these things:
    
- Naming of variables, functions and files
- Structure of code and files
- Explicitness

Each of those things, and plenty of others, really stem from the same concept: **humans are the ones reading and writing code**.

Quality of code should be measured by how easy it is for humans to understand and modify it.

However, the computer doesn't care much about those things. As long as the code you wrote is syntactically correct, it'll happily execute your instructions.

## Why not optimize for development speed, then?

Since maintainability doesn't affect the computer, there are benefits to allocating less thought and energy into it. It’s faster, for one.

You're reading this post about code quality, so there’s a good chance you know what it’s like to bang out some code late into the night. Getting logic out of your head and onto the screen as fast as you can, iterating quickly on what you learn and feeling some pride when you run it and see it work.
You’re too excited to think about optimizing variable names or checking that you have a system of inputs and outputs.

Projects like these are how a lot of developers got into writing code to begin with, myself included. It’s exciting and it’s immediately satisfying. Without those hits of dopamine, many of those projects never get off the ground.


Spending time thinking about naming, structure and explicitness isn’t as gratifying as seeing end results quickly, and that’s ok.
Those projects are about learning and prototyping. They’re not meant to last.

{/*
## What is “good”, anyway?


*/}

## What about when code does need to last?

When the code you write is for a company or your own startup, it suddenly matters a lot if it lasts. Code written quickly and recklessly has an expiration date.

Being thoughtful and deliberate is key, and it's hard to do those things quickly.

When you build with an emphasis on development speed, you can get things up and running, but you can only pray that things always follow the happy path. Any deviation is a risk.

When you build maintainably, you can sleep well knowing that things **will** go wrong, but you’ve designed your software to make it easy to identify problems and be precise with the debugging and resolution.

Maintainable code has clear inputs and outputs. It produces intermediate artifacts so that a single failure doesn't require fully restarting a workflow.

Those are gifts you give to future maintainers to quickly diagnose problems and confidently react to them.

## ...

Writing more maintainably slows down the release of features. Neither devs nor product managers should be interested in things that slow down getting features released.

So how can we make the case that maintainability isn't just a virtue, but actually beneficial to business?
    
How about money?

## Writing maintainable code makes your company money

Maintainable code is modifiable code. When would you need to modify code?

Most industries are constantly changing. Sometimes in small ways, sometimes in big ways.

Social media companies constantly stumble onto impactful features like stories, and other apps find themselves under pressure to mimic them.
Governments pass laws that change how banks, insurance companies and self-driving vehicle companies operate, sometimes with short notice.

Any product manager will tell you how critical it is to be able to react quickly in these scenarios.
Falling behind the competition can be a dagger.

If you can’t react to a changing environment, you’re at a disadvantage relative to your competitors. If you can, you’re at an advantage.

Reaction time is a competitive advantage. And competitive advantages make your company money.

## How can you minimize reaction time?

What *is* reaction time?

It’s the amount of time it takes for a developer to understand the current state of the code and move it to the desired state.

Any code that currently exists will have to be revisited by a human and modified to move it to the desired state.

You can’t modify something you don’t understand, and that quality of being easily understood is at the very core of what it means to be maintainable.

**When variables are named thoughtfully and inputs and outputs are clearly defined, future maintainers will be able to open a file and quickly understand how they can start moving from one state to another.**

Thoughtful structure anticipates that the requirements might change. Sometimes in predictable ways, sometimes in wholly unpredictable ways.
The bet you make when you write thoughtfully is that you are minimizing the friction for a future maintainer to adapt your code.

When the competition can’t adjust as quickly, it’s not because their current engineers are worse. It’s because all humans require time to understand what they’re looking at and navigate the environment. We can’t change that.
But we can make the environment easy or difficult to navigate, and that’s where thoughtful, maintainable code shines. Not when it’s written, but when it’s revisited.

## Final takeaway

If you want to build a reputation as someone who consistently anticipates change and enables their team to edge out the competition, write code with this question in mind:

**How can I maximize the number of future developers that can be introduced to this code, understand what it does quickly and make a change to it confidently?**
    
    </Post>
</Container>